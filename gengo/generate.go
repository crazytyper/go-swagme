package gengo

import (
	"fmt"

	"github.com/crazytyper/swagme"
)

// GenerateModels generates the models for a swagger spec.
// Generates the source code for a single go file starting with a generated code header
// followed by a package declaration followed by the types from the swagger spec.
func GenerateModels(w *Writer, packagename string, spec *swagme.Spec) error {
	w.WriteSinglelineComment("Code generated by swagme")
	w.WriteBlankLine()

	if info := spec.Info; info != nil {
		w.WriteSinglelineComment(fmt.Sprintf("package %s defines models for %s %s", packagename, info.Title, info.Version))
	}

	w.WritePackage(packagename)

	// generate enums
	for _, enum := range buildEnums(spec.Definitions) {
		w.WriteBlankLine()
		if err := generateEnum(w, &enum); err != nil {
			w.WriteMultilineCommentf(`ERROR with enum %q:\n%v`, enum.Name, err)
		}
	}

	// generate structs
	for name, definition := range spec.Definitions {
		w.WriteBlankLine()
		if err := generateDefinition(w, name, definition); err != nil {
			w.WriteMultilineCommentf(`ERROR with definition %q:\n%v`, name, err)
		}
	}

	return nil
}

func generateDefinition(w *Writer, name string, definition *swagme.Definition) error {
	switch definition.Type {
	case swagme.TString:
		w.WriteField(publicName(name), "string", fmt.Sprintf(`json:"%s"`, name))

	case swagme.TObject:
		w.WriteStructStart(name)
		for propname, property := range definition.Properties {
			if err := generateProperty(w, propname, property); err != nil {
				w.WriteSinglelineComment(fmt.Sprintf("Failed to generate property %q: %v", propname, err.Error()))
			}
		}
		w.WriteStructEnd()

	default:
		return fmt.Errorf("type %q not implemented yet", definition.Type)
	}
	return nil
}

func generateProperty(w *Writer, name string, property *swagme.Property) error {
	n := ""
	t := ""
	if property.Ref != "" {
		n = string(property.Ref)
		t = typeNameForRef(property.Ref)
	} else {
		n = string(property.Type)
		t = typeName(property.Type)
	}

	if t != "" {
		w.WriteField(publicName(name), t, fmt.Sprintf(`json:"%s"`, name))
		return nil
	}

	switch property.Type {
	case swagme.TArray:
		return generateArrayProperty(w, name, property)

	case swagme.TObject:
		return generateObjectProperty(w, name, property)
	}

	return fmt.Errorf("type %q not implemented yet", n)
}

func generateArrayProperty(w *Writer, name string, property *swagme.Property) error {
	n := ""
	t := ""
	if property.Items.Ref != "" {
		n = string(property.Items.Ref)
		t = typeNameForRef(property.Items.Ref)
	} else {
		n = string(property.Items.Type)
		t = typeName(property.Items.Type)
	}

	if t != "" {
		w.WriteField(publicName(name), "[]"+t, fmt.Sprintf(`json:"%s"`, name))
		return nil
	}

	return fmt.Errorf("array item type %q not implemented yet", n)
}

func generateObjectProperty(w *Writer, name string, property *swagme.Property) error {
	n := ""
	t := ""
	if property.AdditionalProperties.Ref != "" {
		n = string(property.AdditionalProperties.Ref)
		t = typeNameForRef(property.AdditionalProperties.Ref)
	} else {
		n = string(property.AdditionalProperties.Type)
		t = typeName(property.AdditionalProperties.Type)
	}

	if t != "" {
		w.WriteField(publicName(name), "map[string]"+t, fmt.Sprintf(`json:"%s"`, name))
		return nil
	}

	return fmt.Errorf("object type %q not implemented yet", n)
}

func generateEnum(w *Writer, enum *enumType) error {
	et := publicName(enum.Name)
	vt := typeName(enum.Type)

	w.writeEOL()

	description := enum.Description
	if description == "" {
		description = "..."
	}
	w.WriteSinglelineComment(et + " " + description)
	w.writeString("type ")
	w.writeString(et)
	w.writeString(" ")
	w.writeString(vt)
	w.writeEOL()

	w.WriteSinglelineComment("Values for enum " + et)
	w.writeString("const (")
	w.writeEOL()

	for _, value := range enum.Values {
		w.writeString(et + publicName(value))
		w.writeString(" ")
		w.writeString(et)
		w.writeString(" = ")
		w.writeString(fmt.Sprintf("%q", value))
		w.writeEOL()
	}

	w.writeString(")")
	w.writeEOL()
	return nil
}
